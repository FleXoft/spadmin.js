20181219:
	- meg kell vizsgálni, milyen módon tud a java-s program key leütésenként vizsgálni stdin-ről
		- https://stackoverflow.com/questions/9964995/java-how-do-you-detect-tab-key-press-within-a-non-gui-application
		- https://sourceforge.net/projects/javacurses/
		- jline3, lásd pom.xml
	- alap program kiépítés, git repo kezelés, alap class-ok
	- készen van egy kis prg, ami karakterenként olvassa be az stdin-ről a jelet, elvileg windows-on és linux-on is működik
		- mvn exec:java -Dexec.mainClass="test.rawconsoleinput.TestRCI"
	- Windows > Preferences > Java > Editor: uncheck Smart caret positioning in Java names
	- Windows > Preferences > General > Keys:
		- Command:"Next Editor" new binding > Ctrl-Tab

20190120:
	- nem általánoskodom, beírom Java Class-okba a lehetséges konfigokat a TSM-es parancsokból, csinálok gyors parsert
	- teszt:
		- mvn exec:java -Dexec.mainClass="test.rawconsoleinput.TestRCI"
		- mvn exec:java -Dexec.mainClass="text.textio.ContactInfo"
		- mvn exec:java -Dexec.mainClass="test.jline3.TestJLine3"
		- mvn exec:java -Dexec.mainClass="test.jline3.Test2"

20190130:
	- elkészítettem a query node parser class-okat
		- lehetőleg általános módon, hogy használni lehessen más definíciókban is

20190422:
	- query node cmd:
		- https://www.ibm.com/support/knowledgecenter/en/SSGSG7_7.1.0/com.ibm.itsm.srv.ref.doc/r_cmd_node_query.html
	- megalkottam a command-tree1.xml fájlt
		- ebben le vannak írva a "query node", "query actlog", "dir" parancsok szintaktikája
		- ebben elvileg minden megvan a TAB-os ellenőrzéshez és kiegészítéshez
	- megvan a command-tree1.xml beolvasása
	- elkezdtem megvalósítani a checkInput fgv-t, részben megvan
		- a seq elemek még nincsenek meg
		- ekkor folytatni kell az ellenőrzést egy adott karaktertől, nem elég az utolsó CmdTreeNode bemenő paraméternek

20190428:
	- a nem megfelelő adatstruktúra miatt nagyon bonyi a parse-olás és lépkedés a cmdTree-ben
	- átalakítom úgy a programot, hogy bármerre lehessen egy node-ról lépkedni, minden node-hoz tárolom:
		- parent
		- child
		- nextSibling

20190429:
	- prg output after parsing
		createNode(CmdTreeRootNode [indexNode=0, type=root])
		node(CmdTreeRootNode [indexNode=0, type=root])
			node(CmdTreeLevelStart [indexNode=1, type=levelStart])
			node(CmdTreeChoice [fixPart=q, fullText=query, indexNode=2, type=choice])
				node(CmdTreeLevelStart [indexNode=3, type=levelStart])
				node(CmdTreeChoice [fixPart=n, fullText=node, indexNode=4, type=choice])
					node(CmdTreeLevelStart [indexNode=5, type=levelStart])
					node(CmdTreeSeq [bCanBeEmpty=true, indexNode=6, listValues=[node1, node2], type=seqList])
					node(CmdTreeSeq [bCanBeEmpty=true, indexNode=7, subNodeName=domains, type=seqSub])
						node(CmdTreeLevelStart [indexNode=8, type=levelStart])
						node(CmdTreeSeq [bCanBeEmpty=false, indexNode=9, fixPart=do, fullText=domain, type=seqText])
						node(CmdTreeSeq [bCanBeEmpty=false, indexNode=10, fixPart==, fullText==, type=seqText])
						node(CmdTreeSeq [bCanBeEmpty=false, indexNode=11, listSeparator=,, listValues=[domain1, domain2], type=seqListSep])
					node(CmdTreeSeq [bCanBeEmpty=true, indexNode=12, subNodeName=format, type=seqSub])
						node(CmdTreeLevelStart [indexNode=13, type=levelStart])
						node(CmdTreeSeq [bCanBeEmpty=false, indexNode=14, fixPart=f, fullText=format, type=seqText])
						node(CmdTreeSeq [bCanBeEmpty=false, indexNode=15, fixPart==, fullText==, type=seqText])
						node(CmdTreeSeq [bCanBeEmpty=false, indexNode=16, subNodeName=formatlist, type=seqSub])
							node(CmdTreeLevelStart [indexNode=17, type=levelStart])
							node(CmdTreeChoice [fixPart=s, fullText=standard, indexNode=18, type=choice])
							node(CmdTreeChoice [fixPart=d, fullText=detailed, indexNode=19, type=choice])
					node(CmdTreeSeq [bCanBeEmpty=true, indexNode=20, subNodeName=auth, type=seqSub])
						node(CmdTreeLevelStart [indexNode=21, type=levelStart])
						node(CmdTreeSeq [bCanBeEmpty=false, indexNode=22, fixPart=auth, fullText=authentication, type=seqText])
						node(CmdTreeSeq [bCanBeEmpty=false, indexNode=23, fixPart==, fullText==, type=seqText])
						node(CmdTreeSeq [bCanBeEmpty=false, indexNode=24, subNodeName=authlist, type=seqSub])
							node(CmdTreeLevelStart [indexNode=25, type=levelStart])
							node(CmdTreeChoice [fixPart=lo, fullText=local, indexNode=26, type=choice])
							node(CmdTreeChoice [fixPart=ld, fullText=ldap, indexNode=27, type=choice])
					node(CmdTreeSeq [bCanBeEmpty=true, indexNode=28, subNodeName=Type, type=seqSub])
						node(CmdTreeLevelStart [indexNode=29, type=levelStart])
						node(CmdTreeSeq [bCanBeEmpty=false, indexNode=30, fixPart=t, fullText=type, type=seqText])
						node(CmdTreeSeq [bCanBeEmpty=false, indexNode=31, fixPart==, fullText==, type=seqText])
						node(CmdTreeSeq [bCanBeEmpty=false, indexNode=32, subNodeName=TypeList, type=seqSub])
							node(CmdTreeLevelStart [indexNode=33, type=levelStart])
							node(CmdTreeChoice [fixPart=c, fullText=client, indexNode=34, type=choice])
							node(CmdTreeChoice [fixPart=nas, fullText=nas, indexNode=35, type=choice])
							node(CmdTreeChoice [fixPart=s, fullText=server, indexNode=36, type=choice])
							node(CmdTreeChoice [fixPart=a, fullText=any, indexNode=37, type=choice])
				node(CmdTreeChoice [fixPart=ac, fullText=actlog, indexNode=38, type=choice])
				node(CmdTreeChoice [fixPart=xx, fullText=xx123, indexNode=39, type=choice])
			node(CmdTreeChoice [fixPart=d, fullText=dir, indexNode=40, type=choice])
	- elvileg kész a parser check :)

20190504:
	- Flex kérésére fixPart és fullText-ből 1 db attr lett, keyWord, amelyben 2 info van, az első nagybetűk azt jelzik, hogy mely karakterek után már keyWord egyezést feltételezünk
		- így átalakítom a prg-t
	- ez kész, de a tab kezelés nagyon bonyi...

20190505:
	- kitaláltam, hogy a tab-ra hogy legyen a következő szó
		- minden node-hoz tárolok egy cmdSample mezőt, ebben ' '-el elválasztva benne van, hogy milyen node-ok elérése után lehet ez a node, indexek vannak benne
			- itt számolom ki: recursiveSetCmdSample

20190509:
	- haladtam a tab-os dologgal
